# Get the number of communities detected.
num_communities <- length(communities_found)
cat("Number of communities detected:", num_communities, "\n")
# Get the community membership for each node.
node_membership <- membership(communities_found)
# Visualize the graph with nodes colored according to their community membership.
plot(communities_found, G,
vertex.size = 6,
vertex.label = NA, # Hide labels for a cleaner plot
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership.
plot(communities_found, G,
vertex.size = 6,
vertex.label = NA, # Hide labels for a cleaner plot
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
vertex.size = 6,
vertex.label.cex = 0.7,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
vertex.size = 6,
vertex.label.cex = 0.3,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership.
plot(communities_found, G,
vertex.size = 6,
vertex.label = NA, # Hide labels for a cleaner plot
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
vertex.size = 6,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
vertex.size = 8,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership.
plot(communities_found, G,
vertex.size = 6,
vertex.label = NA, # Hide labels for a cleaner plot
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
layout = layout_with_fr(G),
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
layout = layout_in_circle(G),
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
layout = layout_with_kk(G),
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
layout = layout_with_kk(G),
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
layout = layout_with_fr(G),
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_louvain, G,
layout = layout_with_fr(G),
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Apply the Louvain algorithm for community detection (based on modularity optimization)
# This is a highly effective and popular method for finding community structures
communities_found <- cluster_louvain(G)
# Print the modularity score (a value > 0.4 usually indicates a good partition)
cat("Modularity score:", round(modularity(communities_found), 4), "\n")
# Print the number of communities found
cat("Number of communities detected:", length(communities_found), "\n")
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, G,
layout = layout_with_fr(G),
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
#comunità
cluster_louvain(G)
length((cluster_louvain(G))) #numero delle comunità presenti
plot(G, vertex.color = c1$membership)
#Robustezza
robustness(G, type = c("vertex", "edge"), measure = c("degree", "random"), N = 100) #non funziona per versione del pacchetto "igraph"
cat("--- Global Network Metrics ---\n")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 8,
vertex.frame.color = "gray",
vertex.label.color = "black",
vertex.label.cex = 0.7,   # Adjust label text size
vertex.label.dist = 1,   # Adjust distance of labels from nodes
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 8,
vertex.frame.color = "gray",
vertex.label.color = "black",
vertex.label.cex = 0.7,   # Adjust label text size
vertex.label.dist = 1,   # Adjust distance of labels from nodes
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Create an undirected graph object using the igraph package
# d = defines the connections (links)
# vertices = defines the individual prisoners
Graph <- graph_from_data_frame(d = edges, directed = FALSE, vertices = nodes)
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 8,
vertex.frame.color = "gray",
vertex.label.color = "black",
vertex.label.cex = 0.7,   # Adjust label text size
vertex.label.dist = 1,   # Adjust distance of labels from nodes
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 8,
vertex.frame.color = "red",
vertex.label.color = "black",
vertex.label.cex = 0.7,   # Adjust label text size
vertex.label.dist = 1,   # Adjust distance of labels from nodes
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 8,
vertex.label.color = "black",
vertex.label.cex = 0.7,   # Adjust label text size
vertex.label.dist = 1,   # Adjust distance of labels from nodes
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 8,
vertex.label.cex = 0.7,   # Adjust label text size
vertex.label.dist = 1,   # Adjust distance of labels from nodes
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 8,
vertex.label.color = "black",
vertex.label.cex = 0.7,   # Adjust label text size
vertex.label.dist = 1,   # Adjust distance of labels from nodes
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 8,
vertex.label.color = "black",
vertex.label.cex = 0.7,   # Adjust label text size
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.width = 0.5,
edge.color="red",
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.width = 0.5,
edge.color="green",
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.width = 0.5,
edge.color="grey",
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.width = 0.5,
edge.color="black",
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.width = 0.5,
edge.color="grey",
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.width = 0.5,
edge.color="green",
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.color="green",
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Check that the network is connected and there aren't isolated subgroups
connect <- is.connected(Graph)
cat("Is the graph connected?", connect, "\n")
transitivity(Graph)
cat("Global Clustering Coefficient (Transitivity):", round(transitivity_score, 4), "\n")
# Calculate the clustering coefficient
clustering <- transitivity(Graph)
cat("Global Clustering Coefficient (Transitivity):", round(clustering, 4), "\n")
cat("Global Clustering Coefficient (Transitivity):", round(clustering, 3), "\n")
cat("Global Clustering Coefficient:", round(clustering, 3), "\n")
# Check that the network is connected and there aren't isolated subgroups
connection <- is.connected(Graph)
cat("Is the graph connected?", connection, "\n")
# Calculate the clustering coefficient (transitivity)
clustering_coeff <- transitivity(Graph)
cat("Global Clustering Coefficient:", round(clustering_coeff, 3), "\n")
# Calculate network density measurement
net_density <- edge_density(Graph)
cat("Network Density:", round(density_score, 3), "\n")
cat("Network Density:", round(net_denisty, 3), "\n")
cat("Network Density:", round(net_density, 3), "\n")
# Cardinality of nodes and edges
num_nodes <- vcount(Graph)
num_edges <- ecount(Graph)
cat("Number of nodes (inmates):", num_nodes, "\n")
cat("Number of edges (friendships):", num_edges, "\n\n")
cat("Number of edges (relations):", num_edges, "\n\n")
# Calculate the degree for each node (number of connections)
degree(Graph)
cat("--- Global Network Metrics ---\n")
cat("--- Cohesive Subgroup Analysis (Cliques) ---\n")
# Find the size of the largest clique in the graph
max_clique_size <- clique_num(Graph)
cat("Size of the largest clique:", max_clique_size, "\n")
# Find the nodes forming the largest clique
max_clique_nodes <- largest_cliques(Graph)
cat("Nodes in the largest clique:", unlist(max_clique_nodes[1]), "\n\n")
cat("Nodes in the largest clique:", unlist(max_clique_nodes[1]), "\n")
cat("Nodes in the largest clique:", unlist(max_clique_nodes[1]))
# Correlate node degree with its clustering coefficient
# This checks if highly-connected nodes are part of tightly-knit groups
cor_degree_clustering <- cor(nodes$degree, nodes$clustering, use = "complete.obs")
cat("Correlation between Degree and Clustering:", round(cor_degree_clustering, 3), "\n")
# Correlate node degree with its number of triangles
# This checks if highly-connected nodes participate in more 3-person relations circles
cor_degree_triangles <- cor(nodes$degree, nodes$triangles)
cat("Correlation between Degree and Triangles:", round(cor_degree_triangles, 3), "\n")
cat("--- Centrality Analysis ---\n")
cat("--- Node Metrics Correlation ---\n")
cat("--- Node Metrics Correlation ---")
cat("--- Node Metrics Correlation ---\n")
\n
"\n"
"\n\n"
cat("--- Node Metrics Correlation ---\n")
# Degree Centralization: Influence based on the number of direct connections
centr_degree(Graph, mode = "all", normalized = TRUE)   # normalized = TRUE allows for comparison across networks of different sizes
degree_centralization <- centr_degree(Graph, mode = "all", normalized = TRUE)$centralization
cat("Network Degree Centralization:", round(degree_centralization, 4), "\n")
# Degree Centralization: Influence based on the number of direct connections
degree_centralization <- centr_degree(Graph, mode = "all", normalized = TRUE)$centralization   # normalized = TRUE allows for comparison across networks of different sizes
cat("Network Degree Centralization:", round(degree_centralization, 4), "\n")
cat("Network Degree Centralization:", round(degree_centralization, 3), "\n")
# Closeness Centralization: Measures how close a node is to all other nodes
closeness_centralization <- centr_clo(Graph, mode = "all", normalized = TRUE)$centralization
cat("Network Closeness Centralization:", round(closeness_centralization, 3), "\n")
# Betweenness Centrality: Measures how often a node acts as a bridge on the shortest path between other nodes
betweenness_scores <- estimate_betweenness(Graph, directed = FALSE, cutoff = -1)
# Extract the top 3 nodes by betweenness
top_brokers <- names(head(sort(betweenness_scores, decreasing = TRUE), 3))
cat("Top 3 'broker' node IDs:", top_brokers, "\n")
cat("Top 3 'broker' node ID's:", top_brokers, "\n")
cat("Top 3 ''broker'' node ID's:", top_brokers, "\n")
cat("Top 3 'broker' node IDs:", top_brokers, "\n")
cat("--- Community Detection ---\n")
# Apply the Louvain algorithm for community detection (based on modularity optimization)
# This is a highly effective and popular method for finding community structures
communities_found <- cluster_louvain(Graph)
# Print the modularity score (a value > 0.4 usually indicates a good partition)
cat("Modularity score:", round(modularity(communities_found), 4), "\n")
# Print the modularity score (a value > 0.4 usually indicates a good partition)
modularity_score <- modularity(communities_found)
cat("Modularity score:", round(modularity_score, 3), "\n")
# Print the number of communities found
num_communities <- length(communities_found)
cat("Number of communities detected:", num_communities, "\n")
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, Graph,
layout = layout_with_fr(Graph),
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Apply the Louvain algorithm for community detection (based on modularity optimization)
# This is a highly effective and popular method for finding community structures
communities_found <- cluster_louvain(Graph)
# Load required libraries for the analysis
library(igraph)
library(Matrix)
# Load nodes and edges from CSV files
# !! Ensure these files are located in the "data" subfolder
nodes <- read.csv("data/nodes.csv", header = TRUE, as.is = TRUE)
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.color="green",
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Create a histogram of nodes degree frequencies
hist(degree(Graph),
main = "Node Degree Histogram",
xlab = "Degree",
ylab = "Frequency (Number of Nodes)",
col = "skyblue2")
# Create a log-log plot to analyze the degree distribution
# This type of plot helps identify scale-free network properties
plot(degree.distribution(Graph), log = "xy",
main = "Log-Log Degree Distribution",
xlab = "Log(Degree)",
ylab = "Log(Intensity)",
col = "skyblue2",
pch = 19)
# Create a scatter plot to show the strong positive correlation between the nodes degree and the number of triangles
plot(nodes$degree, nodes$triangles,
main = "Node Degree vs. Number of Triangles",
xlab = "Node Degree",
ylab = "Number of Triangles",
pch = 19,
col = "skyblue2")
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, Graph,
layout = layout_with_fr(Graph),
vertex.size = 12,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, Graph,
layout = layout_with_fr(Graph),
vertex.size = 10,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, Graph,
layout = layout_with_fr(Graph),
vertex.size = 8,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 10,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.color="green",
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Generate a basic plot of the network for a first visual inspection
plot(Graph,
vertex.color = "skyblue2",
vertex.size = 8,
vertex.label.color = "black",
vertex.label.cex = 0.5,   # Adjust label text size
edge.color="green",
edge.width = 0.5,
main = "Prison Inmate Relations Network")
# Create a scatter plot to show the strong positive correlation between the nodes degree and the number of triangles
plot(nodes$degree, nodes$triangles,
main = "Node Degree vs. Number of Triangles",
xlab = "Node Degree",
ylab = "Number of Triangles",
pch = 19,
col = "skyblue2")
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, Graph,
layout = layout_with_fr(Graph),
vertex.size = 8,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Load required libraries for the analysis
library(igraph)
library(Matrix)
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, Graph,
layout = layout_with_fr(Graph),
vertex.size = 8,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Create a scatter plot to show the strong positive correlation between the nodes degree and the number of triangles
plot(nodes$degree, nodes$triangles,
main = "Node Degree vs. Number of Triangles",
xlab = "Node Degree",
ylab = "Number of Triangles",
pch = 19,
col = "skyblue2")
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, Graph,
layout = layout_with_fr(Graph),
vertex.size = 8,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, Graph,
layout = layout_with_fr(Graph),
vertex.size = 8,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, Graph,
layout = layout_with_fr(Graph),
vertex.size = 8,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Visualize the graph with nodes colored according to their community membership
plot(communities_found, Graph,
layout = layout_with_fr(Graph),
vertex.size = 8,
vertex.label.cex = 0.5,
main = "Network Communities (Louvain Algorithm)")
# Print the number of communities found
num_communities <- length(communities_found)
cat("Number of communities detected:", num_communities, "\n")
